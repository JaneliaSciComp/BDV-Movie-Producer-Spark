package org.janelia.saalfeldlab.n5.bdv.movie;

import bdv.cache.CacheControl;
import bdv.tools.movie.MovieProducer;
import bdv.tools.movie.preview.MovieFrameInst;
import bdv.tools.movie.serilizers.MovieFramesSerializer;
import bdv.util.BdvFunctions;
import bdv.util.BdvOptions;
import bdv.util.BdvStackSource;
import bdv.util.RandomAccessibleIntervalMipmapSource;
import bdv.viewer.Interpolation;
import bdv.viewer.ViewerPanel;
import bdv.viewer.ViewerState;
import bdv.viewer.animate.SimilarityTransformAnimator;
import bdv.viewer.overlay.MultiBoxOverlayRenderer;
import bdv.viewer.overlay.ScaleBarOverlayRenderer;
import bdv.viewer.render.MultiResolutionRenderer;
import bdv.viewer.render.PainterThread;
import net.imglib2.realtransform.AffineTransform3D;
import org.apache.commons.lang.SerializationUtils;
import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import picocli.CommandLine;
import picocli.CommandLine.Option;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;

import static bdv.tools.movie.MovieProducer.accel;

public class DistributedMovieProducer implements Callable<Void>, Serializable {

    @Option(names = {"-i", "--n5Path"}, required = false, description = "N5 path for saving, e.g. /home/fused.n5")
    private String n5Path = "/Volumes/flyem/render/n5/Z0720_07m_CNS.n5";

    @Option(names = {"-d", "--n5Dataset"}, required = false, description = "N5 dataset - e.g. /ch488")
    private String n5Group = "/full_cns";

    @Option(names = {"-j", "--json"}, required = false, description = "json file generated by BDV movie producer, e.g. /home/transformations.json")
    private String jsonTransformations = "/Users/zouinkhim/Desktop/test3.json";


    @Option(names = {"-o", "--out"}, required = false, description = "Output folder for PNGs")
    private String outputFolder = "/Users/zouinkhim/Desktop/test_video";


    @Option(names = {"-w", "--width"}, required = false, description = "Output Width")
    int width = 8000;

    @Option(names = {"-h", "--height"}, required = false, description = "Output Height")
    int height = 8000;

    @Option(names = {"-b", "--batch"}, required = false, description = "Batch size per Spark task")
    int batch = 10;


    @Override
    public Void call() throws Exception {
        final long time = System.currentTimeMillis();

        final String n5Path = this.n5Path;
        final String n5Group = this.n5Group;
        final String outputFolder = this.outputFolder;
        final Integer width = this.width;
        final Integer height = this.height;

        final ArrayList<MovieFrameInst> movieFrames = MovieFramesSerializer.getFrom(new File(jsonTransformations));

        final List<ArrayList<VideoProducerStep>> batches = VideoProducerStep.generateBatches(movieFrames, batch);
        System.out.println("Generated " + batches.size() + " batches.");

        // Testing serialization
        // SerializationUtils.serialize(movieFrames);
        // SerializationUtils.serialize((Serializable) batches);

        final SparkConf conf = new SparkConf().setAppName("DistributedMovieProducer");
        // TODO: REMOVE
        //conf.setMaster("local");
        //conf.set("spark.driver.bindAddress", "127.0.0.1");

        final JavaSparkContext sc = new JavaSparkContext(conf);
        sc.setLogLevel("ERROR");
        System.out.println("spark started..");

        JavaRDD<ArrayList<VideoProducerStep>> rdd = sc.parallelize(batches);
        rdd.foreach(batchElements -> {
            System.out.println("Starting batch from " + batchElements.get(0).getFileIndex() + " sized: " + batchElements.size());

			// TODO: somehow inject code
            // function( RandomAccessibleInterval, scaleLevel ) >> RandomAccessibleInterval
            final RandomAccessibleIntervalMipmapSource<?> mipmapSource = OpenNonVolatile.createMipmapSource(n5Path, n5Group);

            final BdvStackSource<?> bdv = BdvFunctions.show(mipmapSource, BdvOptions.options());

            ViewerPanel viewer = bdv.getBdvHandle().getViewerPanel();
            viewer.setInterpolation( Interpolation.NLINEAR );

            final ViewerState renderState = viewer.state();
            final ScaleBarOverlayRenderer scalebar = new ScaleBarOverlayRenderer();

            int screenWidth = viewer.getDisplayComponent().getWidth();
            int screenHeight = viewer.getDisplayComponent().getHeight();
            double ratio = Math.min(width * 1.0 / screenWidth, height * 1.0 / screenHeight);

            final AffineTransform3D viewerScale = new AffineTransform3D();

            viewerScale.set(
                    ratio, 0, 0, 0,
                    0, ratio, 0, 0,
                    0, 0, 1.0, 0);

            final MultiBoxOverlayRenderer box = new MultiBoxOverlayRenderer(width, height);

            final MovieProducer.Target target = new MovieProducer.Target(width, height);

            final MultiResolutionRenderer renderer = new MultiResolutionRenderer(
                    target,
                    new PainterThread(null),
                    new double[]{1.0},
                    0l,
                    12,
                    null,
                    false,
                    viewer.getOptionValues().getAccumulateProjectorFactory(),
                    new CacheControl.Dummy());

            int currentFrame = 0;
            int frames = 0;
            int accel = 0;
            SimilarityTransformAnimator animator = null;
            for (VideoProducerStep videoProducerStep : batchElements) {
                if (videoProducerStep.getFrame() > currentFrame || (animator == null)) {
                    currentFrame = videoProducerStep.getFrame();
                    frames = movieFrames.get(currentFrame).getFrames();
                    accel = movieFrames.get(currentFrame).getAccel();
                    animator = new SimilarityTransformAnimator(
                            movieFrames.get(currentFrame - 1).getTransform(),
                            movieFrames.get(currentFrame).getTransform(),
                            0,
                            0,
                            0);
                }

                final AffineTransform3D tkd = animator.get(accel((double) videoProducerStep.getStep() / (double) frames, accel));

                tkd.preConcatenate(viewerScale);
                viewer.state().setViewerTransform(tkd);
                renderState.setViewerTransform(tkd);
                renderer.requestRepaint();
                try {
                    renderer.paint(renderState);
                } catch (final Exception e) {
                    e.printStackTrace();
                    return;
                }

                final BufferedImage bi = target.renderResult.getBufferedImage();

                final Graphics2D g2 = bi.createGraphics();
                g2.drawImage(bi, 0, 0, null);

                /* scalebar */
                g2.setClip(0, 0, width, height);
                scalebar.setViewerState(renderState);
                scalebar.paint(g2);
                box.setViewerState(renderState);
                box.paint(g2);

                /* save image */
                String file = String.format("%s/img-%04d.png", outputFolder, videoProducerStep.getFileIndex());
                ImageIO.write(bi, "png", new File(file));

                System.out.println("saved:" + file);
            }
            bdv.close();


        });

        sc.close();

        System.out.println("done, took: " + (System.currentTimeMillis() - time) + " ms.");
        return null;
    }

    public static void main(String[] args) throws IOException {
        System.out.println(Arrays.toString(args));
        System.exit(new CommandLine(new DistributedMovieProducer()).execute(args));
    }

}
